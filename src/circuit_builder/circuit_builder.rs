//! Tools & traits for PLONK circuits

use crate::commitment_scheme::kzg10::PublicParameters;
use crate::constraint_system::{StandardComposer, Variable};
use anyhow::{Error, Result};
use dusk_bls12_381::Scalar as BlsScalar;
use std::io;

/// Circuit representation for a gadget with all of the tools that it
/// should implement.
pub trait Circuit
where
    Self: Sized,
{
    /// Gadget implementation used to fill the composer.
    //fn gadget(composer: &mut StandardComposer)
    /// Compiles the circuit by using a function that returns a `Result`
    /// with the `ProverKey`, `VerifierKey` and the public inputs vector.
    fn compile_circuit(pub_params: &PublicParameters) -> Result<Self, Error>;

    /// Generate a function that will be able to setup the public inputs for the
    /// upcomming circuit generations & verifications.
    //fn pi_setup_fn_generation(&'a self) -> Fn(Self, &'a [BlsScalar]) -> &'a Vec<BlsScalar>;

    /// Write to files the `ProverKey` & `VerifierKey` generated by the
    /// `compile_circuit` fn.
    fn write_keys(&self, pk_path: &str, vk_path: &str) -> Result<(), io::Error>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::constraint_system::StandardComposer;
    use crate::proof_system::{Prover, ProverKey, Verifier, VerifierKey};
    use anyhow::{Error, Result};
    use std::fs::File;
    use std::io::Write;

    // Implements a circuit that checks:
    // 1) a + b = c where C is a PI
    // 2) a <= 2^6
    // 3) b <= 2^5
    // 4) a * b = d where D is a PI
    pub struct TestCircuit {
        prover_key: ProverKey,
        verifier_key: VerifierKey,
        /*pi_constructor: &'a Vec<(usize, &'a str)>,*/
    }

    impl Circuit for TestCircuit {
        fn compile_circuit(pub_params: &PublicParameters) -> Result<Self, Error> {
            let test_circuit_gadget = |composer: &mut StandardComposer,
                                       a: BlsScalar,
                                       b: BlsScalar,
                                       c: BlsScalar,
                                       d: BlsScalar|
             -> Vec<(usize, &str)> {
                let mut pi = Vec::new();
                let a = composer.add_input(a);
                let b = composer.add_input(b);
                // Make first constraint a + b = c
                composer.poly_gate(
                    a,
                    b,
                    composer.zero_var,
                    BlsScalar::zero(),
                    BlsScalar::one(),
                    BlsScalar::one(),
                    BlsScalar::one(),
                    BlsScalar::zero(),
                    -c,
                );
                pi.push((composer.circuit_size(), "Public input called \"C\""));
                // Check that a and b are in range
                composer.range_gate(a, 1 << 6);
                composer.range_gate(b, 1 << 5);
                // Make second constraint a * b = d
                composer.poly_gate(
                    a,
                    b,
                    composer.zero_var,
                    BlsScalar::one(),
                    BlsScalar::zero(),
                    BlsScalar::zero(),
                    BlsScalar::one(),
                    BlsScalar::zero(),
                    -d,
                );
                pi.push((composer.circuit_size(), "Public input called \"D\""));
                pi
            };
            // Setup PublicParams
            let (ck, vk) = pub_params.trim(1 << 9)?;
            // Generate & save `ProverKey` with some random values.
            let a = BlsScalar::from(25u64);
            let b = BlsScalar::from(5u64);
            let c = BlsScalar::from(30u64);
            let d = BlsScalar::from(125u64);
            let mut prover = Prover::new(b"TestCircuit");
            prover.preprocess(&ck)?;
            let pi = test_circuit_gadget(prover.mut_cs(), a, b, c, d);
            let prover_key = prover.prover_key.unwrap();
            // Generate & save `VerifierKey` with some random values.
            let mut verifier = Verifier::new(b"TestCircuit");
            test_circuit_gadget(verifier.mut_cs(), a, b, c, d);
            verifier.preprocess(&ck).unwrap();
            let verifier_key = verifier.verifier_key.unwrap();
            Ok(TestCircuit {
                prover_key,
                verifier_key,
                //pi_constructor: &pi,
            })
        }

        /*fn pi_setup_fn_generation(&'a self) -> Fn(Self, &[BlsScalar]) -> &Vec<BlsScalar> {
            fn gen_verification_pi(circuit: &TestCircuit) -> &'a Vec<BlsScalar> {
                circuit.pi_constructor.iter()
            }
        }*/

        fn write_keys(&self, pk_path: &str, vk_path: &str) -> Result<(), io::Error> {
            let mut prover_file = File::create(pk_path)?;
            prover_file.write(&self.prover_key.to_bytes()[..])?;

            let mut verifier_file = File::create(vk_path)?;
            verifier_file.write(&self.verifier_key.to_bytes()[..])?;
            Ok(())
        }
    }

    #[test]
    fn test_full() {
        let pub_params = PublicParameters::setup(1 << 10, &mut rand::thread_rng()).unwrap();
        let circuit = TestCircuit::compile_circuit(&pub_params).unwrap();
        circuit.write_keys("pk_testcirc", "vk_testcirc").unwrap();
    }
}
